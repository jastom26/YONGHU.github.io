<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>枝枝的歌单</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">枝枝的歌单</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarContent">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarContent">
                <ul class="navbar-nav me-auto">
                    <li class="nav-item"><a class="nav-link" href="index.html">首页</a></li>
                    <li class="nav-item"><a class="nav-link active" href="songs.html">歌曲列表</a></li>
                </ul>
                <div class="d-flex">
                    <span class="badge animate-pulse me-2" id="liveStatus">
                        <i class="bi bi-mic-mute"></i> 直播结束
                    </span>
                    <a href="https://live.douyin.com/86913268181" target="_blank" class="btn btn-outline-light btn-sm">
                        <i class="bi bi-play-circle"></i> 前往直播间
                    </a>
                </div>
            </div>
        </div>
    </nav>

    <div class="container mt-4">
        <h1 class="mb-4">枝枝的歌单列表</h1>

        <div class="mb-4 row align-items-center">
            <div class="col-md-6 mb-3 mb-md-0">
                <input type="text" id="searchInput" class="form-control" placeholder="搜索歌名或歌手..." aria-label="搜索歌曲">
            </div>
            <div class="col-md-4 mb-3 mb-md-0">
                <select id="genreFilter" class="form-select" aria-label="筛选风格">
                    <option value="">所有风格</option>
                </select>
            </div>
            <div class="col-md-2">
                <button id="randomButton" class="btn btn-primary w-100" title="随机播放一首歌">
                    <i class="bi bi-shuffle"></i> 随机一首
                </button>
            </div>
        </div>

        <div id="loading" class="text-center my-5" style="display: none;">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">加载中...</span>
            </div>
            <p class="mt-2">歌单加载中...</p>
        </div>

        <div class="table-responsive">
            <table class="table table-hover table-striped" id="songTable" style="display: none;">
                <thead>
                    <tr>
                        <th scope="col">歌名</th>
                        <th scope="col">歌手</th>
                        <th scope="col">风格</th>
                        </tr>
                </thead>
                <tbody id="songList">
                    </tbody>
            </table>
        </div>

        <div class="stats-box p-3 bg-light rounded text-center my-4">
            <div class="d-flex justify-content-around align-items-center flex-wrap">
                <div class="p-2">
                    <h5 class="mb-0">总歌曲数: <span id="totalSongsCount">0</span></h5>
                </div>
                <div class="p-2">
                    <h5 class="mb-0">常见风格:</h5>
                    <div id="genreStatsDisplay" class="d-flex flex-wrap justify-content-center mt-2">
                        </div>
                </div>
            </div>
        </div>
    </div>

    <div id="customToast" class="custom-toast"></div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // 全局变量存储歌曲数据
        let allSongs = [];
        let genreStats = [];
        let currentSortColumn = null;
        let currentSortDirection = 'asc';

        // GitHub原始CSV文件链接
        const apiUrl = 'https://raw.githubusercontent.com/jastom26/yonghu.github.io/main/SL.%E6%9E%9D%E4%BB%8A%E5%B1%B1%E3%81%AESONGLIST-sheet1.csv';

        // 页面加载完成时执行
        document.addEventListener('DOMContentLoaded', () => {
            loadSongs();
            setupEventListeners();
            detectLiveStatus(); // 初始化直播状态检测
        });

        // 加载歌曲数据
        async function loadSongs() {
            try {
                const loading = document.getElementById('loading');
                const songTable = document.getElementById('songTable');
                const randomButton = document.getElementById('randomButton');
                const searchInput = document.getElementById('searchInput');
                const genreFilter = document.getElementById('genreFilter');

                // 显示加载状态
                if (loading) loading.style.display = 'block';
                if (songTable) songTable.style.display = 'none';
                if (randomButton) randomButton.disabled = true;
                if (searchInput) searchInput.disabled = true;
                if (genreFilter) genreFilter.disabled = true;

                // 添加超时处理
                const timeoutPromise = new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('请求超时')), 10000)
                );

                // 获取数据
                const response = await Promise.race([
                    fetch(apiUrl),
                    timeoutPromise
                ]);

                if (!response.ok) throw new Error(`HTTP错误 ${response.status}`);

                // 从这里开始解析CSV数据
                const csvText = await response.text();
                allSongs = parseCSV(csvText); // 调用新的parseCSV函数

                // 简化歌手处理：只取第一个歌手
                allSongs = allSongs.map(song => {
                    // 处理歌手：如果有逗号，取第一个
                    if (song['歌手'] && song['歌手'].includes(',')) {
                        song['歌手'] = song['歌手'].split(',')[0].trim();
                    }

                    // 自动修正空值
                    if (!song['歌手'] || song['歌手'].trim() === '') {
                        song['歌手'] = '未知歌手';
                    }

                    if (!song['风格'] || song['风格'].trim() === '') {
                        song['风格'] = '未知风格';
                    }

                    // 由于备注列已移除，此处无需处理备注字段
                    return song;
                });

                // 生成风格统计
                if (allSongs.length > 0) {
                    const genreCount = {};

                    allSongs.forEach(song => {
                        const genre = song['风格'] || '未知';
                        genreCount[genre] = (genreCount[genre] || 0) + 1;
                    });

                    // 转换为数组并排序
                    genreStats = Object.keys(genreCount).map(genre => {
                        return { genre, count: genreCount[genre] };
                    }).sort((a, b) => b.count - a.count);

                    // 保存统计信息到localStorage
                    localStorage.setItem('songStats', JSON.stringify({
                        songCount: allSongs.length,
                        genreStats: genreStats
                    }));
                }

                // 更新UI
                if (loading) loading.style.display = 'none';
                if (songTable) songTable.style.display = 'table';
                if (randomButton) randomButton.disabled = false;
                if (searchInput) searchInput.disabled = false;
                if (genreFilter) genreFilter.disabled = false;

                // 填充风格筛选器
                populateGenreFilter();

                // 显示歌曲
                displaySongs(allSongs);

                // 添加行点击事件
                addRowClickEvents();

                // 更新总歌曲数
                document.getElementById('totalSongsCount').textContent = allSongs.length;
                displayGenreStats();

                // 显示加载成功通知
                showToast('歌单加载成功!');

            } catch (error) {
                console.error('加载歌曲失败:', error);
                const loading = document.getElementById('loading');
                if (loading) {
                    loading.textContent = '加载失败: ' + (error.message || '未知错误');
                    loading.style.color = 'red';
                }
                showToast('加载歌单失败: ' + (error.message || '未知错误'), 'error');
            }
        }

        // 设置事件监听器
        function setupEventListeners() {
            document.getElementById('searchInput').addEventListener('input', filterSongs);
            document.getElementById('genreFilter').addEventListener('change', filterSongs);
            document.getElementById('randomButton').addEventListener('click', playRandomSong);

            // 添加排序事件监听器
            document.querySelectorAll('#songTable th').forEach(header => {
                header.addEventListener('click', () => {
                    const column = header.getAttribute('scope');
                    if (column) { // 排除非排序列
                        sortTable(column);
                    }
                });
            });
        }

        // 显示歌曲
        function displaySongs(songsToDisplay) {
            const songList = document.getElementById('songList');
            songList.innerHTML = ''; // 清空现有列表

            if (songsToDisplay.length === 0) {
                // 修改了colspan从5到3 (歌名、歌手、风格)
                songList.innerHTML = '<tr><td colspan="3" class="text-center">没有找到符合条件的歌曲。</td></tr>';
                return;
            }

            songsToDisplay.forEach((song) => { // 移除了index
                const row = songList.insertRow();
                row.dataset.songName = song['歌名']; // 用于复制，使用'歌名'
                row.dataset.artistName = song['歌手']; // 用于复制
                // 移除了 # 号的单元格
                row.insertCell().textContent = song['歌名']; // 使用'歌名'
                row.insertCell().textContent = song['歌手'];
                row.insertCell().textContent = song['风格'];
                // 移除了备注的单元格
            });
            addRowClickEvents(); // 重新绑定点击事件
        }

        // 过滤歌曲
        function filterSongs() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const selectedGenre = document.getElementById('genreFilter').value;

            const filtered = allSongs.filter(song => {
                const matchesSearch = (song['歌名'] && song['歌名'].toLowerCase().includes(searchTerm)) || // 使用'歌名'
                                      (song['歌手'] && song['歌手'].toLowerCase().includes(searchTerm));
                const matchesGenre = (selectedGenre === '' || song['风格'] === selectedGenre);
                return matchesSearch && matchesGenre;
            });
            displaySongs(filtered);
        }

        // 填充风格筛选器
        function populateGenreFilter() {
            const genreFilter = document.getElementById('genreFilter');
            genreFilter.innerHTML = '<option value="">所有风格</option>'; // 清空并添加默认选项

            const uniqueGenres = [...new Set(allSongs.map(song => song['风格']).filter(Boolean))].sort(); // 过滤空值并排序
            uniqueGenres.forEach(genre => {
                const option = document.createElement('option');
                option.value = genre;
                option.textContent = genre;
                genreFilter.appendChild(option);
            });
        }

        // 播放随机歌曲并复制
        async function playRandomSong() {
            if (allSongs.length === 0) {
                showToast('歌单为空，无法随机播放。', 'warning');
                return;
            }
            const randomIndex = Math.floor(Math.random() * allSongs.length);
            const randomSong = allSongs[randomIndex];
            const copyText = `点歌 - ${randomSong['歌名']} - ${randomSong['歌手']}`; // 使用'歌名'

            try {
                await navigator.clipboard.writeText(copyText);
                showToast(`随机到：${randomSong['歌名']} - ${randomSong['歌手']} (已复制)`, 'success'); // 使用'歌名'
            } catch (err) {
                console.error('复制失败:', err);
                showToast(`随机到：${randomSong['歌名']} - ${randomSong['歌手']} (复制失败)`, 'error'); // 使用'歌名'
            }
        }

        // 添加表格行点击事件并复制
        function addRowClickEvents() {
            const rows = document.querySelectorAll('#songTable tbody tr');
            rows.forEach(row => {
                row.addEventListener('click', async function() {
                    const songName = this.dataset.songName;
                    const artistName = this.dataset.artistName;
                    const copyText = `点歌 - ${songName} - ${artistName}`;

                    try {
                        await navigator.clipboard.writeText(copyText);
                        showToast(`已复制：${songName} - ${artistName}`, 'success');
                    } catch (err) {
                        console.error('复制失败:', err);
                        showToast(`复制失败：${songName} - ${artistName}`, 'error');
                    }
                });
            });
        }

        // 排序表格
        function sortTable(column) {
            if (currentSortColumn === column) {
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortColumn = column;
                currentSortDirection = 'asc';
            }

            const sortedSongs = [...allSongs].sort((a, b) => {
                let valA = a[column];
                let valB = b[column];

                if (typeof valA === 'string') {
                    return currentSortDirection === 'asc' ? valA.localeCompare(valB, 'zh-CN') : valB.localeCompare(valA, 'zh-CN');
                } else {
                    return currentSortDirection === 'asc' ? valA - valB : valB - valA;
                }
            });
            displaySongs(sortedSongs);
            updateSortIndicators(column);
        }

        // 更新排序箭头
        function updateSortIndicators(sortedColumn) {
            document.querySelectorAll('#songTable th').forEach(header => {
                header.classList.remove('sorted-asc', 'sorted-desc');
                if (header.getAttribute('scope') === sortedColumn) {
                    header.classList.add(`sorted-${currentSortDirection}`);
                }
            });
        }

        // 显示自定义Toast提示
        function showToast(message, type = 'success') {
            const toast = document.getElementById('customToast');
            toast.textContent = message;
            toast.className = 'custom-toast show'; // 重置类名
            toast.classList.add(`custom-toast-${type}`); // 添加类型类名

            // 移除旧的类型类名，确保每次只显示一个
            ['custom-toast-success', 'custom-toast-error', 'custom-toast-warning', 'custom-toast-info'].forEach(cls => {
                if (cls !== `custom-toast-${type}`) {
                    toast.classList.remove(cls);
                }
            });

            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000); // 3秒后隐藏
        }

        // 显示风格统计信息
        function displayGenreStats() {
            const genreStatsDisplay = document.getElementById('genreStatsDisplay');
            if (!genreStatsDisplay) return;

            genreStatsDisplay.innerHTML = '';
            // 显示前5个风格，如果少于5个就显示所有
            const topGenres = genreStats.slice(0, 5);
            if (topGenres.length === 0) {
                 genreStatsDisplay.innerHTML = '<span class="badge bg-secondary me-2">暂无风格数据</span>';
                 return;
            }

            topGenres.forEach(stat => {
                const span = document.createElement('span');
                span.className = 'badge bg-info text-dark me-2 mb-1';
                span.textContent = `${stat.genre} (${stat.count})`;
                genreStatsDisplay.appendChild(span);
            });
        }


        // 检测直播状态
        function detectLiveStatus() {
            const liveStatus = document.getElementById('liveStatus');
            
            if (!liveStatus) return;
            
            // 检测直播状态
            const isLive = checkLiveStatus();
            
            if (isLive) {
                liveStatus.innerHTML = '<i class="bi bi-broadcast-pin"></i> 正在直播';
                liveStatus.classList.add('bg-danger', 'animate-pulse');
                liveStatus.classList.remove('bg-secondary');
            } else {
                liveStatus.innerHTML = '<i class="bi bi-mic-mute"></i> 直播结束';
                liveStatus.classList.remove('bg-danger', 'animate-pulse');
                liveStatus.classList.add('bg-secondary');
            }
            
            // 每5分钟更新一次状态
            setTimeout(detectLiveStatus, 5 * 60 * 1000);
        }

        // 根据时间判断直播状态（你现有逻辑）
        function checkLiveStatus() {
            const now = new Date();
            const hours = now.getHours();
            const minutes = now.getMinutes();
            
            // 转换为分钟数
            const currentMinutes = hours * 60 + minutes;
            
            // 定义直播时间段（14:00-15:00 和 18:00-19:30）
            const livePeriod1 = { start: 14*60, end: 15*60 };
            const livePeriod2 = { start: 18*60, end: 19*60+30 };
            
            return (currentMinutes >= livePeriod1.start && currentMinutes <= livePeriod1.end) ||
                   (currentMinutes >= livePeriod2.start && currentMinutes <= livePeriod2.end);
        }


        // 新增函数：用于解析CSV文本 - 动态读取表头
        function parseCSV(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim() !== ''); // 过滤空行
            if (lines.length === 0) return [];

            // 处理可能存在的BOM头
            const firstLine = lines[0].startsWith('\ufeff') ? lines[0].substring(1) : lines[0];

            const headers = firstLine.split(',').map(header => header.trim()); // 获取表头

            const result = [];
            for (let i = 1; i < lines.length; i++) {
                // 使用正则表达式处理CSV，允许逗号在引号内
                // 这个简单的split适用于没有复杂逗号或换行的CSV，如果CSV内容复杂，可能需要更健壮的CSV解析库
                const values = lines[i].split(',').map(value => value.trim());
                
                const row = {};
                headers.forEach((header, index) => {
                    row[header] = values[index] || ''; // 确保有值，避免undefined
                });
                result.push(row);
            }
            return result;
        }

    </script>
</body>
</html>
